<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Touch Yellow</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='45' fill='%23f2a922' stroke='%23333' stroke-width='10'/></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&family=Roboto:wght@700&display=swap" rel="stylesheet">
    
    <style>
        * { box-sizing: border-box; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden; user-select: none; touch-action: none; font-family: 'Roboto', sans-serif; display: flex; justify-content: center; align-items: center; }
        
        #game-container {
            width: 100%; max-width: 177.78vh; aspect-ratio: 16/9;
            position: relative; background: #000000; overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            transition: background-color 0.3s;
        }

        .layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #gfx-layer { z-index: 10; }
        #phy-layer { z-index: 20; pointer-events: auto; }
        #ui-layer { z-index: 30; pointer-events: none; }

        /* --- VISUALS --- */
        .visual-path { 
            position: absolute; 
            background-color: #26a9e1; 
            /* MAGIC FIX: This shadow fills sub-pixel cracks without making the block look messy */
            box-shadow: 0 0 0 1px #26a9e1; 
        }
        .visual-goal { position: absolute; background-color: #f1a92a; box-shadow: 0 0 0 1px #f1a92a; }
        .visual-obs { position: absolute; background-color: #000000; } 
        
        .hitbox { position: absolute; opacity: 0; cursor: crosshair; }
        
        /* DEBUG STYLES */
        #game-container.debug { background-color: #330000; } 
        .debug .path-box { border: none; background: transparent; }
        .debug .goal-box { opacity: 0.8; border: 3px solid #00ff00; background: rgba(0, 255, 0, 0.3); z-index: 100; }
        .debug .obstacle-box { opacity: 0.8; border: 3px solid #ff0000; background: rgba(255, 0, 0, 0.5); z-index: 100; }

        .menu-content { pointer-events: auto; text-align: center; width: 100%; height: 100%; position: relative; background-color: #4d4d4d; }
        .title { position: absolute; width: 100%; top: 10%; font-family: 'Luckiest Guy', cursive; color: #f2ef45; font-size: 10cqi; line-height: 0.9; text-transform: uppercase; text-shadow: 0.4cqi 0.4cqi 0 #000; }
        .menu-btn-wrapper { position: absolute; display: flex; align-items: center; pointer-events: auto; }
        #btn-start-wrap { left: 5%; bottom: 25%; height: 12%; }
        #btn-exit-wrap { left: 5%; bottom: 8%; height: 12%; }
        .circle-btn { height: 100%; aspect-ratio: 1/1; background-color: #f2a922; border-radius: 50%; border: 0.5cqi solid #333; cursor: pointer; transition: transform 0.1s; }
        .circle-btn:hover { transform: scale(1.1); filter: brightness(1.1); }
        .label { font-size: 4cqi; font-weight: 900; color: #000; margin-left: 2cqi; white-space: nowrap; }

        #toggle-wrap { position: absolute; right: 8%; bottom: 15%; display: flex; flex-direction: column; align-items: center; pointer-events: auto; }
        .switch-label { font-family: 'Luckiest Guy', cursive; color: #f2ef45; font-size: 3cqi; margin-bottom: 1cqi; text-shadow: 0.1cqi 0.1cqi 0 #000; }
        .switch { position: relative; display: inline-block; width: 8cqi; height: 4cqi; }
        .switch input { opacity: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #333; border-radius: 4cqi; border: 0.3cqi solid #000; transition: .4s; }
        .slider:before { position: absolute; content: ""; height: 2.6cqi; width: 2.6cqi; left: 0.4cqi; bottom: 0.4cqi; background-color: white; border-radius: 50%; transition: .4s; }
        input:checked + .slider { background-color: #f2a922; }
        input:checked + .slider:before { transform: translateX(4cqi); }

        @keyframes slicerMove {
            0% { transform: translateY(0%); }      
            50% { transform: translateY(200%); }   
            100% { transform: translateY(0%); }    
        }

        @keyframes waterfallDrop {
            0% { transform: translateY(-250%); }
            100% { transform: translateY(250%); }
        }
    </style>
</head>
<body oncontextmenu="return false;">

    <div id="game-container">
        <div id="gfx-layer" class="layer"></div>
        <div id="phy-layer" class="layer"></div>
        <div id="ui-layer" class="layer">
            <div id="menu-screen" class="menu-content">
                <h1 class="title">Touch Yellow</h1>
                <div id="btn-start-wrap" class="menu-btn-wrapper">
                    <div id="start-btn" class="circle-btn"></div>
                    <div class="label"><- Start/Restart</div>
                </div>
                <div id="btn-exit-wrap" class="menu-btn-wrapper">
                    <div class="circle-btn" onclick="Engine.exit()"></div>
                    <div class="label" style="font-size: 6cqi;"><-Exit</div>
                </div>
                <div id="toggle-wrap">
                    <div class="switch-label" id="mode-text">Hover Mode</div>
                    <label class="switch">
                        <input type="checkbox" id="mode-check" onchange="Engine.toggleMode()">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
        </div>
    </div>

    <script>
        const Logger = {
            log: (msg, type='info') => {
                const styles = { info: 'color: #26a9e1', success: 'color: #f1a92a; font-weight: bold', death: 'color: #ff4444; font-weight: bold', system: 'color: #888' };
                console.log(`%c[Game] ${msg}`, styles[type] || styles.info);
            }
        };

        const PluginManager = {
            hooks: {},
            on: function(e, cb) { (this.hooks[e] = this.hooks[e] || []).push(cb); },
            trigger: function(e, d) { if(this.hooks[e]) this.hooks[e].forEach(cb=>cb(d)); }
        };

        // --- PRECISE GEOMETRY ENGINE ---
        // No overlap logic used. Blocks meet exactly. CSS Shadow handles the visual cracks.
        const DrawLevel1Layout = (draw) => {
            const THICK_H = 14; 
            const THICK_W = 7.875; 
            
            // Anchor Points
            const BOTTOM_Y = 62;
            const MID_Y    = 42;
            const TOP_Y    = 22;
            
            const LEFT_X   = 55 - THICK_W;  
            const RIGHT_X  = 90 - THICK_W; 
            
            // 1. Bottom Path (0 to Vertical 1)
            // Width goes EXACTLY to the right edge of Vertical 1 (55%)
            draw.path(0, BOTTOM_Y, 55, THICK_H);
            
            // 2. Vertical 1 (Bottom to Mid)
            // Starts at 55-Thick. Height spans exactly from Mid to Bottom+Thick
            draw.path(LEFT_X, MID_Y, THICK_W, (BOTTOM_Y - MID_Y) + THICK_H);
            
            // 3. Middle Path (Vertical 1 to Vertical 2)
            // Starts at Left X. Width goes to Right X + Thick
            draw.path(LEFT_X, MID_Y, (RIGHT_X - LEFT_X) + THICK_W, THICK_H);
            
            // 4. Vertical 2 (Mid to Top)
            draw.path(RIGHT_X, TOP_Y, THICK_W, (MID_Y - TOP_Y) + THICK_H);
            
            // 5. Top Path (Vertical 2 back to Left)
            const GOAL_X = 15;
            // Starts at Goal X. Width goes to Right X + Thick
            draw.path(GOAL_X, TOP_Y, (RIGHT_X - GOAL_X) + THICK_W, THICK_H);

            return { 
                goalX: GOAL_X, 
                goalY: TOP_Y, 
                thickH: THICK_H, 
                thickW: THICK_W,
                startY: BOTTOM_Y,
                midY: MID_Y,
                topY: TOP_Y,
                v1X: LEFT_X,
                v2X: RIGHT_X
            };
        };

        const LevelData = {
            1: (draw) => {
                const g = DrawLevel1Layout(draw);
                draw.goal(g.goalX, g.goalY - g.thickH, g.thickW, g.thickH, 2);
            },
            
            2: (draw) => {
                const g = DrawLevel1Layout(draw);
                
                // Safe Start (Top Left - Overlaps goal area)
                draw.path(g.goalX, g.goalY - g.thickH, g.thickW, g.thickH * 2);
                
                // Goal (Bottom Left - Matches Menu Position)
                draw.goal(5, 63, 6.75, 12, 3);

                // Obstacle (Bottom Path)
                const obsW = g.thickW * 0.6; 
                const obsH = g.thickH * 1.5; 
                const obsY = g.startY - (g.thickH * 1.5);
                draw.obstacle(30, obsY, obsW, obsH, "slicerMove 2s linear infinite");
            },

            3: (draw) => {
                const g = DrawLevel1Layout(draw);
                
                // Safe Start (Bottom Left)
                draw.path(0, g.startY, 20, g.thickH); 

                // Goal (Top Left)
                draw.goal(g.goalX, g.goalY - g.thickH, g.thickW, g.thickH, "menu");

                const obsW = g.thickW * 0.6; 
                const obsH = g.thickH * 1.5; 
                
                // 1. Bottom Path Slicer
                draw.obstacle(28, g.startY - (g.thickH * 1.5), obsW, obsH, "slicerMove 2s linear infinite");

                // 2. Middle Path Slicer
                draw.obstacle(55, g.midY - (g.thickH * 1.5), obsW, obsH, "slicerMove 1.5s linear infinite");

                // 3. THE WATERFALL (Top Path)
                const waterX = 70; // On Top Path
                const waterY = g.topY;
                const waterAnim = "waterfallDrop 2.5s linear infinite";
                draw.obstacle(waterX, waterY, obsW, obsH, waterAnim);
                draw.obstacle(waterX, waterY, obsW, obsH, waterAnim + " -0.83s");
                draw.obstacle(waterX, waterY, obsW, obsH, waterAnim + " -1.66s");
            }
        };

        const Engine = {
            container: document.getElementById('game-container'),
            layers: { gfx: document.getElementById('gfx-layer'), phy: document.getElementById('phy-layer'), ui: document.getElementById('ui-layer') },
            ui: { menu: document.getElementById('menu-screen'), startBtn: document.getElementById('start-btn'), modeCheck: document.getElementById('mode-check'), modeText: document.getElementById('mode-text'), toggleWrap: document.getElementById('toggle-wrap') },
            state: { active: false, dragging: false, holdMode: false, debug: false, isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) },

            init: function() {
                if (this.state.isMobile) { this.state.holdMode = true; this.ui.toggleWrap.style.display = 'none'; }
                this.ui.startBtn.onmousedown = () => this.startLevel(1);
                this.ui.startBtn.ontouchstart = () => this.startLevel(1);
                window.addEventListener('mousemove', e => this.handleInput(e.clientX, e.clientY));
                window.addEventListener('touchmove', e => { if (this.state.active) { e.preventDefault(); this.handleInput(e.touches[0].clientX, e.touches[0].clientY, e.touches.length > 1); } }, {passive: false});
                window.addEventListener('mouseup', e => this.handleRelease(e));
                window.addEventListener('touchend', e => this.handleRelease(e));
                window.addEventListener('mousedown', e => { if(e.button === 2 && this.state.active) this.die("Panic Click"); });
                Logger.log("Engine Initialized");
            },

            toggleMode: function() {
                if (this.state.isMobile) return;
                this.state.holdMode = this.ui.modeCheck.checked;
                this.ui.modeText.innerText = this.state.holdMode ? "Hold Mode" : "Hover Mode";
                this.ui.modeText.style.color = this.state.holdMode ? "#f2a922" : "#f2ef45";
            },

            builder: {
                path: (x, y, w, h) => Engine.spawnEntity(x, y, w, h, 'visual-path', 'hitbox path-box'),
                goal: (x, y, w, h, next) => {
                    const el = Engine.spawnEntity(x, y, w, h, 'visual-goal', 'hitbox goal-box');
                    el.hitbox.dataset.next = next;
                },
                obstacle: (x, y, w, h, anim) => {
                    const el = Engine.spawnEntity(x, y, w, h, 'visual-obs', 'hitbox obstacle-box'); 
                    el.gfx.style.animation = anim;
                    el.hitbox.style.animation = anim; 
                }
            },

            spawnEntity: function(x, y, w, h, gfxClass, phyClass) {
                const gfx = document.createElement('div'); gfx.className = gfxClass;
                gfx.style.left = x + '%'; gfx.style.top = y + '%'; gfx.style.width = w + '%'; gfx.style.height = h + '%';
                this.layers.gfx.appendChild(gfx);
                
                const phy = document.createElement('div'); phy.className = phyClass;
                phy.style.position = 'absolute';
                phy.style.left = x + '%'; phy.style.top = y + '%'; phy.style.width = w + '%'; phy.style.height = h + '%';
                this.layers.phy.appendChild(phy);
                return { gfx, hitbox: phy };
            },

            startLevel: function(lvl) {
                Logger.log(`Starting Level ${lvl}`);
                if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(e=>{});
                this.layers.gfx.innerHTML = ''; this.layers.phy.innerHTML = '';
                this.ui.menu.style.display = 'none'; this.state.dragging = true;
                if (LevelData[lvl]) LevelData[lvl](this.builder);
                this.state.active = false;
                setTimeout(() => { this.state.active = true; PluginManager.trigger('startLevel', lvl); }, 50);
            },

            handleInput: function(x, y, multi) {
                if (!this.state.active) return;
                if (this.state.holdMode && !this.state.dragging) return;
                if (multi) { this.die("Multi-touch"); return; }
                const target = document.elementFromPoint(x, y);
                if (target && target.classList.contains('goal-box')) {
                    this.state.active = false;
                    const next = target.dataset.next;
                    Logger.log("Goal Reached!", "success");
                    if (next === "menu") { alert("You Beat The Game!"); this.reset(); } 
                    else { this.startLevel(parseInt(next)); }
                    return;
                }
                const isSafe = target && (target.classList.contains('path-box') || target.classList.contains('goal-box'));
                if (!isSafe) {
                    let reason = "Void";
                    if(target && target.classList.contains('obstacle-box')) reason = "Obstacle Hit";
                    this.die(reason);
                }
            },

            handleRelease: function(e) {
                if (e.button === 2) return;
                if (this.state.active && this.state.holdMode) this.die("Released Button");
            },

            die: function(reason) {
                Logger.log(`Died: ${reason}`, "death");
                this.state.active = false; PluginManager.trigger('death', reason); this.reset();
            },

            reset: function() {
                Logger.log("Resetting to Menu");
                this.state.active = false; this.state.dragging = false;
                this.ui.menu.style.display = 'block';
                this.layers.gfx.innerHTML = ''; this.layers.phy.innerHTML = '';
                if (document.fullscreenElement) document.exitFullscreen();
            },
            exit: function() { this.reset(); },
            toggleDebug: function() { 
                this.state.debug = !this.state.debug; 
                this.container.classList.toggle('debug'); 
                Logger.log(`Hitbox Mode: ${this.state.debug}`);
            }
        };

        Engine.init();
        window.cmd = (c) => {
            if (c === 'hitbox') Engine.toggleDebug();
            if (c === 'load menu') Engine.reset();
            if (c === 'load level1') Engine.startLevel(1);
            if (c === 'load level2') Engine.startLevel(2);
            if (c === 'load level3') Engine.startLevel(3);
        };
    </script>
</body>
</html>