<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Touch Yellow</title>
    
    <!-- Tab Logo -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='45' fill='%23f2a922' stroke='%23333' stroke-width='10'/></svg>">
    
    <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&family=Roboto:wght@700&display=swap" rel="stylesheet">
    <style>
        /* RESET */
        * { box-sizing: border-box; }
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background-color: black; 
            overflow: hidden; 
            font-family: 'Roboto', sans-serif; 
            user-select: none;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 16:9 CONTAINER */
        #game-container {
            width: 100%;
            max-width: 177.78vh; 
            aspect-ratio: 16/9;
            position: relative;
            background-color: #4d4d4d; 
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        .screen { position: absolute; width: 100%; height: 100%; top: 0; left: 0; }
        #menu-screen { z-index: 20; }
        #game-screen { background-color: black; z-index: 10; display: none; }

        /* TITLE */
        .title { 
            position: absolute; width: 100%; top: 10%;
            font-family: 'Luckiest Guy', cursive; color: #f2ef45; 
            font-size: 10cqi; 
            line-height: 0.9; 
            text-transform: uppercase; 
            text-shadow: 0.4cqi 0.4cqi 0 #000;
            text-align: center; 
        }

        /* MENU ITEMS */
        .menu-item { position: absolute; display: flex; align-items: center; }
        #start-item { left: 5%; bottom: 25%; height: 12%; }
        #exit-item { left: 5%; bottom: 8%; height: 12%; }

        .circle { 
            height: 100%; aspect-ratio: 1/1; 
            background-color: #f2a922; 
            border-radius: 50%; 
            border: 0.5cqi solid #333; 
            cursor: pointer; 
            transition: transform 0.1s;
        }
        .label { 
            font-size: 4cqi; font-weight: 900; color: #000; 
            margin-left: 2cqi; white-space: nowrap; pointer-events: none;
        }
        .label-large { font-size: 6cqi; }
        .circle:hover { transform: scale(1.1); filter: brightness(1.1); }
        .circle:active { transform: scale(0.95); }

        /* TOGGLE SWITCH */
        #toggle-item { position: absolute; right: 8%; bottom: 15%; display: flex; flex-direction: column; align-items: center; }
        .switch-label { font-family: 'Luckiest Guy', cursive; color: #f2ef45; font-size: 3cqi; text-transform: uppercase; margin-bottom: 1cqi; text-shadow: 0.1cqi 0.1cqi 0 #000; }
        .switch { position: relative; display: inline-block; width: 8cqi; height: 4cqi; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #333; transition: .4s; border-radius: 4cqi; border: 0.3cqi solid #000; }
        .slider:before { position: absolute; content: ""; height: 2.6cqi; width: 2.6cqi; left: 0.4cqi; bottom: 0.4cqi; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #f2a922; }
        input:checked + .slider:before { transform: translateX(4cqi); }

        /* GAME OBJECTS */
        .path { position: absolute; background-color: #26a9e1; z-index: 11; pointer-events: auto; }
        .goal { position: absolute; background-color: #f1a92a; z-index: 12; pointer-events: auto; cursor: pointer; }
        
        /* THE OBSTACLE */
        .obstacle { 
            position: absolute; 
            background-color: black; 
            z-index: 15; 
            pointer-events: auto;
        }

        /* OBSTACLE ANIMATION */
        /* Start HIGH up (-50% relative to self, placed high by JS), slide DOWN past the path */
        @keyframes slicerMove {
            0% { transform: translateY(0%); }      /* Starts high (hidden above) */
            50% { transform: translateY(150%); }   /* Slides WAY down (hidden below) */
            100% { transform: translateY(0%); }    /* Goes back up */
        }

        /* DEBUG */
        .debug-border { border: 2px solid red !important; opacity: 0.8; }
        .debug-obs { border: 2px solid purple !important; background-color: rgba(128,0,128,0.5) !important; }
    </style>
</head>
<body oncontextmenu="return false;">

    <div id="game-container">
        <!-- MENU -->
        <div id="menu-screen" class="screen">
            <h1 class="title">Touch Yellow</h1>
            
            <div id="start-item" class="menu-item">
                <div id="start-btn" class="circle" 
                     onmousedown="startLevel(1)" 
                     ontouchstart="startLevel(1)"></div>
                <div class="label"><- Start/Restart</div>
            </div>

            <div id="exit-item" class="menu-item">
                <div class="circle" onclick="exitGame()"></div>
                <div class="label label-large"><-Exit</div>
            </div>

            <div id="toggle-item">
                <div class="switch-label" id="mode-text">Hover Mode</div>
                <label class="switch">
                    <input type="checkbox" id="mode-check" onchange="toggleMode()">
                    <span class="slider"></span>
                </label>
            </div>
        </div>

        <!-- GAME -->
        <div id="game-screen" class="screen"></div>
    </div>

    <script>
        const container = document.getElementById('game-container');
        const menu = document.getElementById('menu-screen');
        const game = document.getElementById('game-screen');
        const startBtn = document.getElementById('start-btn');
        const modeText = document.getElementById('mode-text');
        
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        let isDraggingFromStart = false;
        let gameActive = false;
        let debugMode = false;
        let holdMode = false;

        if (isMobile) {
            holdMode = true;
            document.getElementById('toggle-item').style.display = 'none'; 
        }

        function toggleMode() {
            if (isMobile) return; 
            holdMode = document.getElementById('mode-check').checked;
            modeText.innerText = holdMode ? "Hold Mode" : "Hover Mode";
            modeText.style.color = holdMode ? "#f2a922" : "#f2ef45";
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement && document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(e => console.log(e));
            }
        }
        function exitFullscreenMode() {
            if (document.fullscreenElement) document.exitFullscreen();
        }

        function startLevel(lvl) {
            toggleFullscreen();

            const w = container.clientWidth;
            const h = container.clientHeight;
            const thick = h * 0.14; 
            
            // --- ALIGNMENT LOGIC ---
            const btnRect = startBtn.getBoundingClientRect();
            const contRect = container.getBoundingClientRect();
            
            const relativeBtnTop = btnRect.top - contRect.top;
            const relativeBtnLeft = btnRect.left - contRect.left;
            const btnCenterY = relativeBtnTop + (btnRect.height / 2);
            
            // PATH COORDINATES
            const startY = btnCenterY - (thick / 2); 

            // PATH GEOMETRY
            const p2Height = h * 0.20; 
            const p4Height = h * 0.24; 

            const p2X = (w * 0.55) - thick;
            const p2Y = startY - p2Height;
            const p3Width = w * 0.35;
            const p4X = p2X + p3Width - thick;
            const p4Y = p2Y - p4Height;
            const p5Width = w * 0.45;
            const topPathLeftX = p4X - p5Width + thick;

            // RENDER
            game.innerHTML = ''; 
            isDraggingFromStart = true;
            menu.style.display = 'none';
            game.style.display = 'block';

            if (lvl === 1) {
                // L1 Layout
                createPath(0, startY, w * 0.55 + 1, thick);
                createPath(p2X, p2Y, thick, p2Height + thick);
                createPath(p2X, p2Y, p3Width + 1, thick);
                createPath(p4X, p4Y, thick, p4Height + thick);
                createPath(topPathLeftX, p4Y, p5Width, thick);
                
                // L1 Goal
                const g = createGoal(topPathLeftX, p4Y - thick, thick, thick);
                g.dataset.nextLevel = 2; 
            }
            else if (lvl === 2) {
                // L2 Layout (Same)
                createPath(0, startY, w * 0.55 + 1, thick);
                createPath(p2X, p2Y, thick, p2Height + thick);
                createPath(p2X, p2Y, p3Width + 1, thick);
                createPath(p4X, p4Y, thick, p4Height + thick);
                createPath(topPathLeftX, p4Y, p5Width, thick);

                // L2 Start Zone
                createPath(topPathLeftX, p4Y - thick, thick, thick * 2);

                // L2 GOAL (Bottom Left)
                const goalSize = btnRect.height;
                const g = createGoal(relativeBtnLeft, relativeBtnTop, goalSize, goalSize);
                g.dataset.nextLevel = "menu";

                // OBSTACLE (The Slicer)
                // Width: 0.6x Thickness (Thinner block)
                const obsW = thick * 0.6;
                const obsH = thick * 3.5; // Tall enough to cover gap
                const obsX = w * 0.35; 
                
                // Start Position: WAY UP (Hidden in black above)
                const obsY = startY - (thick * 1.5); 
                
                const obs = document.createElement('div');
                obs.className = 'obstacle';
                if(debugMode) obs.classList.add('debug-obs');
                obs.style.left = obsX + 'px';
                obs.style.top = obsY + 'px';
                obs.style.width = obsW + 'px';
                obs.style.height = obsH + 'px';
                // 2.0s Duration, as requested
                obs.style.animation = "slicerMove 2s linear infinite"; 
                game.appendChild(obs);
            }

            gameActive = true; 
        }

        function handleMove(clientX, clientY, multiTouch) {
            if (!gameActive) return;
            if (holdMode && !isDraggingFromStart) return;
            if (multiTouch) { die(); return; }

            const target = document.elementFromPoint(clientX, clientY);

            // Win
            if (target && target.classList.contains('goal')) {
                gameActive = false;
                const next = target.dataset.nextLevel;
                
                if (next == 2) {
                    startLevel(2);
                } else {
                    alert("You Beat The Game!");
                    resetToMenu();
                }
                return;
            }

            // Death Check
            const isSafe = target && (
                target.classList.contains('path') || 
                target.classList.contains('goal')
            );

            if (!isSafe) {
                if(debugMode) console.log("Died on:", target);
                die();
            }
        }

        function die() {
            gameActive = false;
            resetToMenu();
        }

        function createPath(l, t, w, h) {
            const d = document.createElement('div');
            d.className = 'path';
            if(debugMode) d.classList.add('debug-border');
            d.style.left = l + 'px'; d.style.top = t + 'px';
            d.style.width = Math.ceil(w) + 'px'; d.style.height = Math.ceil(h) + 'px';
            game.appendChild(d);
        }

        function createGoal(l, t, w, h) {
            const d = document.createElement('div');
            d.className = 'goal';
            if(debugMode) d.classList.add('debug-border');
            d.style.left = l + 'px'; d.style.top = t + 'px';
            d.style.width = Math.ceil(w) + 'px'; d.style.height = Math.ceil(h) + 'px';
            game.appendChild(d);
            return d;
        }

        function resetToMenu() {
            gameActive = false;
            isDraggingFromStart = false;
            game.style.display = 'none';
            menu.style.display = 'block'; 
        }

        function exitGame() {
            exitFullscreenMode();
            resetToMenu();
        }

        // Listeners
        window.addEventListener('mousemove', e => gameActive && handleMove(e.clientX, e.clientY));
        window.addEventListener('touchmove', e => {
            if(gameActive) { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY, e.touches.length > 1); }
        }, {passive: false});
        
        const handleRelease = (e) => { 
            if (e.button === 2) return; 
            if (gameActive && holdMode) die(); 
        };
        window.addEventListener('mouseup', handleRelease);
        window.addEventListener('touchend', handleRelease);

        window.addEventListener('mousedown', (e) => {
            if (e.button === 2 && gameActive) die(); 
        });

        // Commands
        window.cmd = (command) => {
            const c = command.toLowerCase().trim();
            if (c === 'hitbox') {
                debugMode = !debugMode;
                document.querySelectorAll('.path, .goal').forEach(e => e.classList.toggle('debug-border'));
                document.querySelectorAll('.obstacle').forEach(e => e.classList.toggle('debug-obs'));
                console.log(`Hitbox Mode: ${debugMode ? "ON" : "OFF"}`);
            } 
            else if (c === 'load menu') resetToMenu();
            else if (c === 'load level1') startLevel(1);
            else if (c === 'load level2') startLevel(2);
        };
    </script>
</body>
</html>